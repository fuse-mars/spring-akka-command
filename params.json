{"name":"Spring-akka-command","tagline":"C in CQRS","body":"### Simple explanation of the code\r\nUser sends a request (restful) to save a record, the controller then creates a command asking the writeWorker to write this record to db. After that an event is published to the Event-stream.\r\nNote: command is the record to be saved (for simplicity)\r\n![Design Schematic](https://raw.githubusercontent.com/fuse-mars/spring-akka-command/master/extra-resource/design-schematic.png)\r\n\r\n### Local connection\r\n```java\r\n//command ... com.nshimiye.cqrs.writer.akka.WriteWorker\r\nActorSelection brokerWorker = AkkaFactory.getActorSystem(SystemType.REMOTE)\r\n                            .actorSelection(\"/user/brokerWorker\");\r\n```\r\n`/user/brokerWorker` is the local path of **brokerWorker** actor\r\n\r\n### Remote connection\r\nAkka Actors connect using either TCP or UDP. In this tutorial, we use TCP connection.\r\nExample below shows how it is done\r\n```java\r\n// query ... com.nshimiye.akka.AkkaInitializer\r\n// Akka configuration values\r\nprivate final String BROKER_URL = \"akka.tcp://AKKAREMOTESystem@192.168.99.101:2555/user/brokerWorker\";\r\n...\r\nActorSelection messageBrokerFinder = AkkaFactory.getActorSystem(SystemType.REMOTE)\r\n       .actorSelection(BROKER_URL);\r\n```\r\n`akka.tcp://AKKAREMOTESystem@192.168.99.101:2555/user/brokerWorker` is the remote path of **brokerWorker** actor.\r\n\r\n### Configuration\r\nWhen an actor system is created, it looks for configuration information from the `application.conf` and/or `reference.conf` files. These files are assumed to be in the resource folder of the application.\r\n\r\nIf none of these are found, the [default configuration](http://doc.akka.io/docs/akka/snapshot/general/configuration.html#akka-actor) is used\r\n \r\nBelow are the required configuration for creating a remote system:\r\n```\r\n// command ... application.conf\r\nakka {\r\n    actor {\r\n      provider = \"akka.remote.RemoteActorRefProvider\"\r\n      serialization-bindings {\r\n        # specify java objects that need to be serialized and the serialization type to be used\r\n      }\r\n    }\r\n    remote {\r\n      enabled-transports = [\"akka.remote.netty.tcp\"]\r\n      netty.tcp {\r\n      hostname = 192.168.99.101     # external (logical) hostname, ex: my.domain.com\r\n      port = 2555                   # external (logical) port\r\n \r\n      bind-hostname = 0.0.0.0       # internal (bind) hostname, ex: local.address \r\n      bind-port = 2553              # internal (bind) port\r\n      }\r\n   }\r\n}\r\n```\r\n* `hostname` and `port` are used by the actor system to listen to incoming connections from other outside actors.\r\nNote: These outside actors have to be part of remote system (same or different from the listening system) in order to connect.\r\n* serialization is very important because it informs the system on how to read/convert the received/sent data over a tcp connection.\r\n\r\n### Actors\r\nTwo different types of actor exist:\r\n* Local actor: actor created inside a local system\r\n* Remote actor: actor created inside a remote system\r\n* Local actors can only communication with other (local and remote) actors on the same JVM\r\n* Remote actor can interact with actors on the same JVM and other remote actors on different JVM or different physical machine.\r\n\r\nExample of actor creation:\r\n* W application\r\n```java\r\n// command ...\r\n// local actor\r\nwriteWorker = AkkaFactory.getActorSystem(SystemType.LOCAL).actorOf(\r\nWriteWorker.createWorker(), \"writeWorker\");\r\n// remote actor\r\nbrokerWorker = AkkaFactory.getActorSystem(SystemType.REMOTE).actorOf(\r\nProps.create(BrokerWorker.class), \"brokerWorker\");\r\n```\r\n* R application\r\n```java\r\n// query ...\r\ndenomalizer = AkkaFactory.getActorSystem(SystemType.REMOTE).actorOf(\r\nProps.create(DenomalizerWorker.class), \"denomalizer\");\r\n```\r\n`writeWorker` can interact with `brokerWorker`. However, it cannot interact with `denomalizer` because they are not on the machines.\r\n\r\n### Event Bus\r\n* Event Bus is a message broker and it's role is to facilitate communication between akka actors.\r\n* Each Akka system has a builtin event bus called **Event Stream**.\r\n* Event Stream can be used to send messages to multiple actors at once (publish-subscribe model).\r\nBelow is an example usage\r\n```java\r\n// command ... com.nshimiye.messaging.BrokerWorker\r\ngetContext().system().eventStream().subscribe(getSender(), Envelope.class);\r\n...\r\ngetContext().system().eventStream().publish((Envelope) message);\r\n```\r\nIn the above example, two things are happening:\r\n* brokerWorker subscribes an actor `getSender()` that requests to be subscribed.\r\n* Later the brokerWorker publishes an event of type `Envelope` to the Event Stream. After this, the Event Stream will send a message to the subscribed actors.\r\n\r\n### Running\r\n* Using docker\r\n * `gradle clean buildDocker`\r\n * `docker run --rm=true -e HOSTNAME=192.168.99.101 --net=host springio/akka-spring-command`\r\n\r\nThe important part here is `--net=host`, which tells the container to bind itself to the docker's main ipaddress instead of going through NAT.","google":"UA-68265226-1","note":"Don't delete this file! It's used internally to help with page regeneration."}